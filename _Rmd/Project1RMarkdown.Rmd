---
title: "ST558 - Project 1"
author: "Bryan Bittner"
date: "`r Sys.Date()`"
output: 
  github_document: default
   
  html_document:
    code_folding: hide
---

# Financial Data Vignette

You might be asking yourself, what exactly is a vignette. Well let me save you the hastle of a google search and answer that question here. A vignette is defined as "a brief evocative description, account, or episode". Now you might ask yourself what evocative means. Rather then get caught in an endless loop, let use an easier to understand definition of a vignette. In this context a vignette is just a short, informative guide for how to use and deploy a lookup on financial data.

This vignette will be centered around a call to an API. The API I chose was created by Polygon.io and it is centered around financial data, specifically stock prices.

Below is a list of packages that were used in the creation of this vignette. The tidyverse, knitr, and dplyr packages are commonly used r packages with a wide variety of uses. The httr and jsonlite packages will be used to call an API an display the results. The remaining packages are lesser known r packages to be used specifically for stock related functions.

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE,fig.path = "../images/")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,fig.path = "../images/")

library(tidyverse)
library(knitr)
library(dplyr)
library(httr)
library(ggplot2)
library(jsonlite)
library(TTR) #Used in the stock symbol lookup

#library(quantmod) #used for prebuilt stock market symbols and charts
#library(tidyquant) #Another package that is prebuilt for stock market lookups
```

The advantage of using an API in code is that we can customize function(s) and have them automatically run and retrieve updated results. This beats manually going out to a website to check the stock ticker.

This program will allow for two separate API calls to retrieve financial information. The first option called "Daily" will give the stock readings for a specific stock ticker on a specific date. The second option is called "Aggregate" and will allow you to pull back the readings for a specific stock over a date range with different timespan and multipliers. We can get into more detail for this below.

Daily Option
The two required field to use this option are "Stock Ticker" and "Date". When the function is called, it will first check to ensure that the call was valid and worked. If a problem occurred, the status and error message will be presented. If the call was successful the following values will be returned:
open, high, low, close, volume

```{r, echo=FALSE}
myAPIKey<-"HewJYeUXkzQB4Fc0VHnfyY7d4roQVjDi"
```

```{r}
isValidSymbol <- function(symbolName){
  #Checks to make sure the stock ticker name is value
  print("Running isValidSymbol function")
  
  #Check to see if the function has already been called, if so, skip over the stockSymbols call to improve performance
  if (exists('symbolsDF')==FALSE) {
    symbolsDF <<- stockSymbols("NASDAQ")  
  }
  
  #Make this a global DF so we can access the name later
  symbolsDFFiltered <<- filter(symbolsDF, Symbol == toupper(symbolName))
  
  if (count(symbolsDFFiltered) > 0){
    return(TRUE)
  }
  
  return(FALSE)
}
```

```{r}
getSymbolByCompanyName<-function(CompanyName)
  
  print("Running getSymbolByCompanyName function")
  
  if (exists('symbolsDF')==FALSE) {
    symbolsDF <<- stockSymbols("NASDAQ")  
  }
  
#To-Do- build a like lookup/filter here
  #symbolsDFFiltered <<- filter(symbolsDF, Symbol == toupper(symbolName))
  
```


```{r}
isValidDate <- function(DateToCheck){
  #Dates in these API lookup must be a valid date and in the YYYY-MM-DD format
  
  print("Running isValidDate function")
  d <- try(as.Date(DateToCheck, format="%Y-%m-%d"))
  if("try-error" %in% class(d) || is.na(d)) {
    return(FALSE)
  }
  return(TRUE)
}
```


```{r}
stockDailyLookup <- function(symbolName, lookupDate, printSummary=TRUE){
  
  print("Running stockDailyLookup function")
  
  #First lets make sure the symbol is valid
  if (isValidSymbol(symbolName)==FALSE){
    return(list("success"=FALSE,"resultsMessage"="Symbol not found"))
  }
  
  #Make sure date is valid and in the YYYY-MM-DD format
  if(isValidDate(lookupDate)==FALSE) {
    return(list("success"=FALSE,"resultsMessage"="Invalid Date"))
  }

  #Past the initial validation checks  - Call the API
  apiLookup<-paste("https://api.polygon.io/v1/open-close/",symbolName,"/",lookupDate,"?adjusted=true&apiKey=",myAPIKey,sep="")
  
  apiDailyData <-GET(apiLookup)
  apiDailyDataParsed <- fromJSON(rawToChar(apiDailyData$content))
  #print(apiDailyDataParsed)

  if (apiDailyDataParsed$status=="NOT_FOUND"){
    return(list("success"=FALSE,"resultsMessage"="Unknown error occurred. Date might be on a weekend or holiday"))
  }
  
  if (apiDailyDataParsed$status=="ERROR"){
    return(list("success"=FALSE,"resultsMessage"=apiDailyDataParsed$error))
  }
  
  if (printSummary==TRUE) {
    print(paste("Summary for '",symbolName," - ",symbolsDFFiltered$Name, "'", sep=""))
    print(paste("Lookup Date: ",lookupDate,sep=""))
    print(paste("Opening Price: $",apiDailyDataParsed$open,sep=""))
    print(paste("Closing Price: $",apiDailyDataParsed$close,sep=""))
    print(paste("Daily High: $",apiDailyDataParsed$high,sep=""))
    print(paste("Daily Low: $",apiDailyDataParsed$low,sep=""))    
  }

  return(list("success"=TRUE,"resultsMessage"="succes!",apiDailyDataParsed))
}
```

```{r}
dailyResults<-stockDailyLookup("AAPL","2022-06-01",TRUE)
```




Pulling data for a specific company on a single day is great and everything, but it doesn't tell us any trends. What if we wanted to pull some history to see if the stock has been going up or down. For that we will need another API. Enter the 'Aggregate' API lookup.

This has some additional parameters that will need to be defined and validated
StockTicker - The ticker symbol of the stock/equity.
DateFrom - The start of the aggregate time window with the format YYYY-MM-DD
DateTo - The end of the aggregate time window with the format YYYY-MM-DD
Multiplier - The size of the timespan multiplier.
timespan - The size of the time window - valid options ('minute','hour','day','week','month','quarter','year')


```{r}
isValidTimespan <- function(timespanToCheck){
  #Make sure the timespan is valid
  print("Running isValidTimespan function")
  
  timespanToCheck<-tolower(timespanToCheck)
  
  if (timespanToCheck %in% "minute" || timespanToCheck %in% "hour" || timespanToCheck %in% "day"
      || timespanToCheck %in% "week" || timespanToCheck %in% "month" || timespanToCheck %in% "quarter"
      || timespanToCheck %in% "year") {
    return(TRUE)
  }

  return(FALSE)
}
```


```{r}
stockAggregateLookup <- function(symbolName, lookupDateFrom, lookupDateTo, multiplier, timespan, printSummary=TRUE, returnResultsList=TRUE){
  
  print("Running stockAggregateLookup function")
  
  #First lets make sure the symbol is valid
  if (isValidSymbol(symbolName)==FALSE){
    return(list("success"=FALSE,"resultsMessage"="Symbol not found"))
  }
  
  #Make sure date from is valid and in the YYYY-MM-DD format
  if(isValidDate(lookupDateFrom)==FALSE) {
    return(list("success"=FALSE,"resultsMessage"="Invalid Date From"))
  }
  
  #Make sure date to is valid and in the YYYY-MM-DD format
  if(isValidDate(lookupDateFrom)==FALSE) {
    return(list("success"=FALSE,"resultsMessage"="Invalid Date To"))
  }
  
  #Make sure timespan is valid
  if(isValidTimespan(timespan)==FALSE) {
    return(list("success"=FALSE,"resultsMessage"="Invalid Timespan"))
  }

  #Past the initial validation checks  - Call the API
  apiLookup<-paste("https://api.polygon.io/v2/aggs/ticker/",symbolName,"/range/",multiplier,"/",timespan,"/",lookupDateFrom,"/",lookupDateTo,"?adjusted=true&sort=asc&limit=1000&apiKey=",myAPIKey,sep="")
  
  apiAggData <-GET(apiLookup)
  apiAggDataParsed <- fromJSON(rawToChar(apiAggData$content))
  #print(max(apiAggDataParsed$results$h))

  if (apiAggDataParsed$status=="NOT_FOUND"){
    return(list("success"=FALSE,"resultsMessage"="Unknown error occurred. Date might be on a weekend or holiday"))
  }
  
  if (apiAggDataParsed$status=="ERROR"){
    return(list("success"=FALSE,"resultsMessage"=apiAggDataParsed$error))
  }
  
  if (apiAggDataParsed$status!="OK"){
    return(list("success"=FALSE,"resultsMessage"="Unknown Error"))
  }
  
  #Convert results timestamp field to readable Date
  apiAggDataParsed$results<-apiAggDataParsed$results %>% 
    mutate(tDate = as.POSIXct(apiAggDataParsed$results$t/1000, origin="1970-01-01"))
  
  if (printSummary==TRUE) {
    print(paste("Summary for '",symbolName," - ",symbolsDFFiltered$Name, "'", sep=""))
    print(paste("Lookup Date From: ",lookupDateFrom,sep=""))
    print(paste("Lookup Date To: ",lookupDateTo,sep=""))
    print(paste("Number of records returned: ",apiAggDataParsed$resultsCount,sep=""))
    print(paste("Opening Price: $",apiAggDataParsed$results$o[1],sep=""))
    print(paste("Closing Price: $",apiAggDataParsed$results$c[apiAggDataParsed$resultsCount],sep=""))
    print(paste("Max Daily High: $",max(apiAggDataParsed$results$h),sep=""))
    print(paste("Min Daily Low: $",min(apiAggDataParsed$results$l),sep=""))
    print(paste("Date of Max: ",apiAggDataParsed$results$tDate[which.max(apiAggDataParsed$results$h)],sep=""))
    print(paste("Date of Low: ",apiAggDataParsed$results$tDate[which.min(apiAggDataParsed$results$l)],sep=""))
  }

  if (returnResultsList==TRUE) {
    parsedResults<-apiAggDataParsed$results %>% mutate(Symbol=symbolsDFFiltered$Symbol,Name=symbolsDFFiltered$Name)
    #print(parsedResults)
    return(parsedResults)
  }
  
}
```


```{r}
stockAggregateLookup(symbolName="MSFT",lookupDateFrom="2022-05-30",lookupDateTo="2022-06-16",multiplier = 1,timespan="day",printSummary=TRUE,returnResultsList=FALSE)
```


# EDA

Now lets use the Aggregate Lookup on and create some graphs and tables.

Lets start with a 30 day lookup on Microsoft.

```{r}
stockResults1<-stockAggregateLookup(symbolName="MSFT",lookupDateFrom=Sys.Date()-31,lookupDateTo=Sys.Date()-1,multiplier = 1,timespan="day",printSummary=FALSE,returnResultsList=TRUE)
```
Here is a printout of some of the values returned from the lookup, as well as the readable date field called 'tDate'.
```{r}
as_tibble(stockResults1)
```


Let try a graph of the data

```{r}
#stockResults1<-stockResults1 %>% mutate(Symbol=symbolsDFFiltered$Symbol,Name=symbolsDFFiltered$Name)
data<-data.frame(stockResults1)

g<-ggplot(data,aes(x=tDate, color=Symbol))
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Microsoft Stock Price over 30 days")
```
That is quite the drop between June 6th and June 15th. Let's focus in on that window

```{r}
stockResults2<-stockAggregateLookup(symbolName="MSFT",lookupDateFrom="2022-06-06",lookupDateTo="2022-06-15",multiplier = 1,timespan="day",printSummary=FALSE,returnResultsList=TRUE)

#stockResults2<-stockResults2 %>% mutate(Symbol=symbolsDFFiltered$Symbol,Name=symbolsDFFiltered$Name)
data<-data.frame(stockResults2)

g<-ggplot(data,aes(x=tDate, color=Symbol)) 
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Microsoft Stock Price")
```

I'm am by no means a financial wizard, but I think you can attribute the drop to the anticipation of the Federal Reserve raising interest rates on June 14th. Let see if we can find a similar effect on another stock. Lets give Amazon a shot.

```{r}
stockResults3<-stockAggregateLookup(symbolName="AMZN",lookupDateFrom="2022-06-06",lookupDateTo="2022-06-15",multiplier = 1,timespan="day",printSummary=FALSE,returnResultsList=TRUE)

#stockResults3<-stockResults3 %>% mutate(Symbol=symbolsDFFiltered$Symbol,Name=symbolsDFFiltered$Name)
data<-data.frame(stockResults3)

g<-ggplot(data,aes(x=tDate, color=Symbol))
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Amazon Stock Price")
```

It looks awfully similar to Microsoft. Just for fun, let's do Apple.

```{r}
stockResults4<-stockAggregateLookup(symbolName="AAPL",lookupDateFrom="2022-06-06",lookupDateTo="2022-06-15",multiplier = 1,timespan="day",printSummary=FALSE,returnResultsList=TRUE)

data<-data.frame(stockResults4)

g<-ggplot(data,aes(x=tDate, color=Symbol))
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Apple Stock Price")
```
I think it is safe to say there is a pattern going on here. Let's plot all three at one and compare.

Wait, we have the data for the three companies stored in three different data frames. Let's see if we can join them together to make plotting easier.

```{r}
stockResultsAll<-full_join(stockResults2,stockResults3)
stockResultsAll<-full_join(stockResultsAll,stockResults4)
stockResultsAll
```
That was easy. Now lets try and plot all three at once.

```{r}
g<-ggplot(data = stockResultsAll,aes(x=tDate, color=Symbol))
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Stock Price Compare")
```

That wasn't quite as dramatic as I hopped. I think the Microsoft price is distorting the results a bit. Let's try it again without Microsoft.

```{r}
g<-ggplot(data = filter(stockResultsAll %>% filter(Symbol!="MSFT"), Symbol == "AAPL" || Symbol == "AMZN"),
  aes(x=tDate, color=Symbol)) 
  g + geom_line(aes(x=tDate, y=o, color=Symbol)) +
  labs(x="Date Range", y="Stock Price", title="Stock Price Compare")
```